{"ast":null,"code":"import { always, block, call, clockRunning, cond, set, startClock, stopClock } from \"../base\";\nimport Clock from \"../core/AnimatedClock\";\nimport { evaluateOnce } from \"../derived/evaluateOnce\";\n\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  var newClock = new Clock();\n  var currentState = animationStateDefaults();\n  var alwaysNode;\n  var isStarted = false;\n  var isDone = false;\n  var wasStopped = false;\n  var animationCallback;\n  var animation = {\n    start: function start(currentAnimationCallback) {\n      animationCallback = currentAnimationCallback;\n\n      if (isStarted) {\n        animationCallback && animationCallback({\n          finished: false\n        });\n        return;\n      }\n\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        return;\n      }\n\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n\n      isStarted = true;\n      evaluateOnce(set(currentState.position, value), currentState.position, function () {\n        alwaysNode = always(set(value, block([cond(clockRunning(newClock), 0, startClock(newClock)), node(newClock, currentState, config), cond(currentState.finished, [call([], function () {\n          isStarted = false;\n\n          if (!wasStopped) {\n            isDone = true;\n          }\n\n          value.__detachAnimation(animation);\n\n          isDone = true;\n\n          if (!wasStopped) {\n            wasStopped = false;\n          }\n        }), stopClock(newClock)]), currentState.position])));\n\n        value.__attachAnimation(animation);\n\n        alwaysNode.__addChild(value);\n      });\n    },\n    __detach: function __detach() {\n      animationCallback && animationCallback({\n        finished: isDone\n      });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: function stop() {\n      if (isDone) {\n        console.warn('Calling stop has no effect as the animation has already completed');\n        return;\n      }\n\n      if (!isStarted) {\n        console.warn(\"Calling stop has no effect as the animation hasn't been started\");\n        return;\n      }\n\n      wasStopped = true;\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: function __stopImmediately_testOnly(result) {\n      animation.stop();\n      isDone = result;\n\n      value.__detachAnimation(animation);\n    }\n  };\n  return animation;\n}\n\nexport default function backwardsCompatibleAnimWrapper(node, animationStateDefaults) {\n  return function (clock, state, config) {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}","map":{"version":3,"sources":["backwardCompatibleAnimWrapper.js"],"names":["newClock","currentState","animationStateDefaults","isStarted","isDone","wasStopped","animation","start","currentAnimationCallback","animationCallback","finished","console","value","evaluateOnce","set","alwaysNode","always","block","cond","clockRunning","startClock","node","call","stopClock","__detach","stop","__stopImmediately_testOnly","result","config","createOldAnimationObject"],"mappings":"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","sourcesContent":["import {\n  always,\n  block,\n  call,\n  clockRunning,\n  cond,\n  set,\n  startClock,\n  stopClock,\n} from '../base';\nimport Clock from '../core/AnimatedClock';\nimport { evaluateOnce } from '../derived/evaluateOnce';\n\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  const newClock = new Clock();\n  const currentState = animationStateDefaults();\n  let alwaysNode;\n  let isStarted = false;\n  let isDone = false;\n  let wasStopped = false;\n  let animationCallback;\n  const animation = {\n    start: currentAnimationCallback => {\n      animationCallback = currentAnimationCallback;\n      if (isStarted) {\n        animationCallback && animationCallback({ finished: false });\n        return;\n      }\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        // inconsistent with React Native\n        return;\n      }\n\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n\n      isStarted = true;\n      evaluateOnce(\n        set(currentState.position, value),\n        currentState.position,\n        () => {\n          alwaysNode = always(\n            set(\n              value,\n              block([\n                cond(clockRunning(newClock), 0, startClock(newClock)),\n                node(newClock, currentState, config),\n                cond(currentState.finished, [\n                  call([], () => {\n                    isStarted = false;\n                    if (!wasStopped) {\n                      isDone = true;\n                    }\n                    value.__detachAnimation(animation);\n                    isDone = true;\n                    if (!wasStopped) {\n                      wasStopped = false;\n                    }\n                  }),\n                  stopClock(newClock),\n                ]),\n                currentState.position,\n              ])\n            )\n          );\n          value.__attachAnimation(animation);\n          alwaysNode.__addChild(value);\n        }\n      );\n    },\n    __detach: () => {\n      animationCallback && animationCallback({ finished: isDone });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: () => {\n      if (isDone) {\n        console.warn(\n          'Calling stop has no effect as the animation has already completed'\n        );\n        return;\n      }\n      if (!isStarted) {\n        console.warn(\n          \"Calling stop has no effect as the animation hasn't been started\"\n        );\n        return;\n      }\n      wasStopped = true;\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: result => {\n      animation.stop();\n      isDone = result;\n      value.__detachAnimation(animation);\n    },\n  };\n  return animation;\n}\n\n/**\n * Depending on the arguments list we either return animation node or return an\n * animation object that is compatible with the original Animated API\n */\nexport default function backwardsCompatibleAnimWrapper(\n  node,\n  animationStateDefaults\n) {\n  return (clock, state, config) => {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}